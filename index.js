const admin = require("firebase-admin");
const express = require("express");
const cors = require("cors");
//const {initializeApp}= require("firebase/app");

const { Timestamp } = require("firebase-admin/firestore");

// Initialise Firebase Admin SDK
admin.initializeApp();
//initializeApp(firebaseConfig);

const app = express();
app.use(cors({ origin: true }));
app.use(express.json()); // Parse JSON body

const db = admin.firestore();

//Middleware d'authentification
async function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Token manquant ou invalide" });
  }

  const idToken = authHeader.split("Bearer ")[1];

  try {
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    const uid = decodedToken.uid;

    const userDoc = await db.collection("utilisateurs").doc(uid).get();

    if (!userDoc.exists) {
      return res.status(404).json({ error: "Utilisateur non trouvÃ©" });
    }

    req.user = { uid, ...userDoc.data() };

    next(); // on continue vers la route
  } catch (error) {
    console.error("Erreur middleware auth:", error);
    return res.status(401).json({ error: "Token invalide ou expirÃ©" });
  }
}

// Middleware pour vÃ©rifier que l'utilisateur a un des rÃ´les autorisÃ©s
function roleMiddleware(allowedRoles) {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ error: "RÃ´le utilisateur non dÃ©fini" });
    }

    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: "AccÃ¨s refusÃ© : rÃ´le non autorisÃ©" });
    }

    next(); // rÃ´le OK, on continue
  };
}


// âœ… Route GET : rÃ©cupÃ©rer tous les menus dâ€™un restaurant
app.get("/menus/:restaurantId", async (req, res) => {
  const restaurantId = req.params.restaurantId;

  try {
    const snapshot = await db.collection("menus")
      .where("restaurantId", "==", restaurantId)
      .get();

    const menus = [];
    snapshot.forEach(doc => {
      menus.push({ id: doc.id, ...doc.data() });
    });

    res.status(200).json({ menus });
  } catch (error) {
    console.error("Erreur rÃ©cupÃ©ration menus:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});

//Route POST :ajouter un nouveau menu
app.post("/menus", authMiddleware,roleMiddleware(["restaurant_admin", "responsable"]), async (req, res) => {
  console.log("RequÃªte reÃ§ue : ", req.body);

  // RÃ©cupÃ©ration des donnÃ©es dans le body
  const { nom, prix, categorie, disponible, restaurantId } = req.body;

  // Validation simple des donnÃ©es obligatoires
  if (!nom || !prix || !categorie || restaurantId === undefined) {
    return res.status(400).json({ error: "DonnÃ©es manquantes" });
  }

  // VÃ©rification du rÃ´le de l'utilisateur connectÃ©
  if (!["restaurant_admin", "responsable"].includes(req.user.role)) {
    return res.status(403).json({ error: "AccÃ¨s refusÃ© : rÃ´le non autorisÃ©" });
  }

  try {
    

    const newMenu = {
      nom,
      prix,
      categorie,
      disponible: disponible ?? true,
      restaurantId,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now()
    };

    const docRef = await db.collection("menus").add(newMenu);
    res.status(201).json({ message: "Plat ajoutÃ©", id: docRef.id });
  } catch (error) {
    console.error("Erreur ajout menu:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});



// âœ… Route POST : Ajouter un restaurant (admin uniquement pour lâ€™instant)
app.post("/restaurants", authMiddleware, async (req, res) => {
  console.log("RequÃªte reÃ§ue (ajout restaurant) :", req.body);

  // VÃ©rifier rÃ´le autorisÃ© (exemple : seulement admin)
  if (req.user.role !== "admin") {
    return res.status(403).json({ error: "AccÃ¨s refusÃ© : rÃ´le non autorisÃ©" });
  }

  const { nom, adresse, telephone, email, description } = req.body;

  // VÃ©rification des champs obligatoires
  if (!nom || !adresse || !telephone || !email || !description) {
    return res.status(400).json({ error: "Tous les champs sont requis" });
  }

  try {
    const nouveauRestaurant = {
      nom,
      adresse,
      telephone,
      email,
      description,
      createdAt: Timestamp.now()
    };

    const docRef = await db.collection("restaurants").add(nouveauRestaurant);
    res.status(201).json({ message: "Restaurant ajoutÃ© avec succÃ¨s", id: docRef.id });
  } catch (error) {
    console.error("Erreur ajout restaurant:", error);
    res.status(500).json({ error: "Erreur lors de l'ajout du restaurant" });
  }
});




// Route GET : rÃ©cupÃ©rer tous les restaurants
app.get("/restaurants", async (req, res) => {
  try {
    const snapshot = await db.collection("restaurants").get();
    if (snapshot.empty) {
      return res.status(200).json({ restaurants: [] });
    }

    const restaurants = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    res.status(200).json({ restaurants });
  } catch (error) {
    console.error("Erreur rÃ©cupÃ©ration restaurants :", error);
    res.status(500).json({ error: "Erreur serveur"Â });
Â Â }
});



app.post("/restaurants", async (req, res) => {
  const { nom, adresse, email, telephone, description } = req.body;

  // Validation basique
  if (!nom || !adresse || !email || !telephone) {
    return res.status(400).json({ error: "Champs obligatoires manquants" });
  }

  try {
    const newRestaurant = {
      nom,
      adresse,
      email,
      telephone,
      description: description || "",
      createdAt: Timestamp.now(),
    };

    const docRef = await db.collection("restaurants").add(newRestaurant);
    res.status(201).json({ message: "Restaurant ajoutÃ©", id: docRef.id });
  } catch (error) {
    console.error("Erreur ajout restaurant:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});

// Route POST : crÃ©er une commande
app.post("/commandes", async (req, res) => {
  const { restaurantId, utilisateurId, plats, total, statut } = req.body;

  // Validation simple des donnÃ©es reÃ§ues
  if (!restaurantId || !utilisateurId || !plats || !Array.isArray(plats) || plats.length === 0 || total === undefined) {
    return res.status(400).json({ error: "DonnÃ©es manquantes ou invalides" });
  }

  try {
   

    const nouvelleCommande = {
      restaurantId,
      utilisateurId,
      plats,
      total,
      statut: statut ?? "en attente",
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    };

    const docRef = await db.collection("commandes").add(nouvelleCommande);

    res.status(201).json({ message: "Commande crÃ©Ã©e avec succÃ¨s", id: docRef.id });
  } catch (error) {
    console.error("Erreur crÃ©ation commande:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});


// Ajoute authMiddleware comme 2e argument, avant la fonction async
app.post("/commandes", authMiddleware, async (req, res) => {
  const { restaurantId, utilisateurId, plats, total, statut } = req.body;

  // Validation simple des donnÃ©es reÃ§ues
  if (!restaurantId || !utilisateurId || !plats || !Array.isArray(plats) || plats.length === 0 || total === undefined) {
    return res.status(400).json({ error: "DonnÃ©es manquantes ou invalides" });
  }

  try {
    // Optionnel : tu peux vÃ©rifier que l'utilisateur connectÃ© est bien celui qui passe la commande
    if (utilisateurId !== req.user.uid) {
      return res.status(403).json({ error: "AccÃ¨s refusÃ© : utilisateur non autorisÃ©" });
    }

    const nouvelleCommande = {
      restaurantId,
      utilisateurId,
      plats,
      total,
      statut: statut ?? "en attente",
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    };

    const docRef = await db.collection("commandes").add(nouvelleCommande);

    res.status(201).json({ message: "Commande crÃ©Ã©e avec succÃ¨s", id: docRef.id });
  } catch (error) {
    console.error("Erreur crÃ©ation commande:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});




// Route GET : rÃ©cupÃ©rer toutes les commandes dâ€™un restaurant
app.get("/commandes/:restaurantId", async (req, res) => {
  const restaurantId = req.params.restaurantId;

  try {
    const snapshot = await db
      .collection("commandes")
      .where("restaurantId", "==", restaurantId)
      .get();

    const commandes = [];
    snapshot.forEach((doc) => {
      commandes.push({ id: doc.id, ...doc.data() });
    });

    res.status(200).json({ commandes });
  } catch (error) {
    console.error("Erreur rÃ©cupÃ©ration commandes:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});

// Route PATCH : seul un RESPONSABLE peut changer le statut d'une commande
app.patch("/commandes/:commandeId", authMiddleware,roleMiddleware(["responsable"]), async (req, res) => {
  const commandeId = req.params.commandeId;
  const { statut } = req.body;

  // Validation
  if (!statut || typeof statut !== "string") {
    return res.status(400).json({ error: "Statut manquant ou invalide" });
  }

  try {
   

    // ðŸ”§ Mise Ã  jour du statut
    await db.collection("commandes").doc(commandeId).update({
      statut,
      updatedAt: Timestamp.now(),
    });

    res.status(200).json({ message: "Statut mis Ã  jour avec succÃ¨s" });
  } catch (error) {
    console.error("Erreur mise Ã  jour commande:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});


// Route GET : rÃ©cupÃ©rer toutes les commandes dâ€™un restaurant
app.get("/commandes/:restaurantId", async (req, res) => {
  const restaurantId = req.params.restaurantId;

  try {
    const snapshot = await db.collection("commandes")
      .where("restaurantId", "==", restaurantId)
      .orderBy("createdAt", "desc")
      .get();

    const commandes = [];
    snapshot.forEach(doc => {
      commandes.push({ id: doc.id, ...doc.data() });
    });

    res.status(200).json({ commandes });
  } catch (error) {
    console.error("Erreur rÃ©cupÃ©ration commandes:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});


//Route GET: Recuperer les commandes d'un utilisateur specifique
app.get("/commandes/utilisateur/:utilisateurId", authMiddleware, async (req, res) => {
  const utilisateurId = req.params.utilisateurId;
  if (utilisateurId !== req.user.uid) {
    return res.status(403).json({ error: "AccÃ¨s refusÃ©" });
  }
  try {
    const snapshot = await db.collection("commandes")
      .where("utilisateurId", "==", utilisateurId)
      .orderBy("createdAt", "desc")
      .get();

    const commandes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.status(200).json({ commandes });
  } catch (error) {
    res.status(500).json({ error: "Erreur serveur" });
  }
});



//application mobile
const { getAuth } = require("firebase-admin/auth");


// Route POST : inscription utilisateur
app.post("/auth/signup", async (req, res) => {
  const { email, password, nom, prenom, telephone, role } = req.body;

  // Validation simple
  if (!email || !password || !nom || !prenom || !telephone) {
    return res.status(400).json({ error: "Tous les champs obligatoires doivent Ãªtre remplis" });
  }

  try {
    // CrÃ©er l'utilisateur dans Firebase Auth
    const userRecord = await getAuth().createUser({
      email,
      password,
      displayName: `${prenom} ${nom}`,
      phoneNumber: telephone, // format international, ex: +2376xxxxxxx
      emailVerified: false,
    });

    // CrÃ©er un document utilisateur dans Firestore avec Timestamp.now()
    await db.collection("utilisateurs").doc(userRecord.uid).set({
      email,
      nom,
      prenom,
      telephone,
      role: role || "client",
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });

    res.status(201).json({ message: "Utilisateur crÃ©Ã© avec succÃ¨s", uid: userRecord.uid });

  } catch (error) {
    console.error("Erreur inscription:", error);
    if (error.code === "auth/email-already-exists") {
      return res.status(400).json({ error: "Cet email est dÃ©jÃ  utilisÃ©" });
    }
    if (error.code === "auth/phone-number-already-exists") {
      return res.status(400).json({ error: "Ce numÃ©ro de tÃ©lÃ©phone est dÃ©jÃ  utilisÃ©" });
    }
    res.status(500).json({ error: "Erreur serveur lors de la crÃ©ation de l'utilisateur" });
  }
});

//Route post : Connexion utilisateur

app.post('/auth/signin', async (req, res) => {
  const { email, password } = req.body;

  // Validation simple
  if (!email || !password) {
    return res.status(400).json({ error: 'Email et mot de passe requis' });
  }

  try {
    // Firebase Admin SDK ne gÃ¨re pas directement la connexion avec email+password,
    // il faut utiliser Firebase Client SDK cÃ´tÃ© frontend pour Ã§a.
    // Mais ici on simule une connexion backend pour validation avec Firebase Auth REST API (option avancÃ©e).
    // Pour simplifier, on peut vÃ©rifier que l'utilisateur existe :

    const userRecord = await getAuth().getUserByEmail(email);

    if (!userRecord) {
      return res.status(401).json({ error: 'Utilisateur non trouvÃ©' });
    }

    // IMPORTANT : La vÃ©rification du mot de passe doit se faire cÃ´tÃ© client (Firebase Client SDK)
    // Sinon, cÃ´tÃ© backend, il faut utiliser lâ€™API REST Firebase Auth (avec token dâ€™API)
    // Sinon tu peux gÃ©rer une authentification custom (hors Firebase Auth standard)

    // Ici, pour l'exemple, on retourne le userRecord si trouvÃ©
    res.status(200).json({ message: 'Connexion rÃ©ussie', uid: userRecord.uid });

  } catch (error) {
    console.error('Erreur connexion:', error);
    res.status(401).json({ error: 'Email ou mot de passe incorrect' });
  }
});

//application web


// Route POST : crÃ©er un responsable de restaurant (admin uniquement)
app.post("/admin/creer-responsable", authMiddleware, roleMiddleware(["admin"]), async (req, res) => {
  // Seul un admin peut crÃ©er un responsable
  if (req.user.role !== "admin") {
    return res.status(403).json({ error: "AccÃ¨s refusÃ© : rÃ´le non autorisÃ©" });
  }

  const { email, password, nom, prenom, telephone, restaurantId } = req.body;

  // ðŸ”’ VÃ©rification simple des champs
  if (!email || !password || !nom || !prenom || !telephone || !restaurantId) {
    return res.status(400).json({ error: "Champs obligatoires manquants" });
  }

  try {
    // CrÃ©ation utilisateur Firebase Auth
    const userRecord = await getAuth().createUser({
      email,
      password,
      displayName: `${prenom} ${nom}`,
      phoneNumber: telephone,
      emailVerified: false,
    });

    // CrÃ©ation profil Firestore
    await db.collection("utilisateurs").doc(userRecord.uid).set({
      email,
      nom,
      prenom,
      telephone,
      role: "responsable",
      restaurantId,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });

    res.status(201).json({
      message: "Responsable crÃ©Ã© avec succÃ¨s",
      uid: userRecord.uid,
    });
  } catch (error) {
    console.error("Erreur crÃ©ation responsable:", error);
    if (error.code === "auth/email-already-exists") {
      return res.status(400).json({ error: "Cet email est dÃ©jÃ  utilisÃ©" });
    }
    if (error.code === "auth/phone-number-already-exists") {
      return res.status(400).json({ error: "Ce numÃ©ro de tÃ©lÃ©phone est dÃ©jÃ  utilisÃ©" });
    }
    res.status(500).json({ error: "Erreur serveur" });
  }
});



// Route POST : CrÃ©er restaurant + responsable en une fois (admin uniquement)
app.post("/admin/ajouter-restaurant-et-responsable", authMiddleware, roleMiddleware(["admin"]), async (req, res) => {
  const { nomRestaurant, adresse, responsableNom, responsablePrenom, responsableEmail, responsablePassword, telephone } = req.body;

  if (!nomRestaurant || !adresse || !responsableNom || !responsablePrenom || !responsableEmail || !responsablePassword || !telephone) {
    return res.status(400).json({ error: "Champs obligatoires manquants" });
  }

  try {
    // âœ… 1. CrÃ©er le user responsable
    const userRecord = await getAuth().createUser({
      email: responsableEmail,
      password: responsablePassword,
      displayName: `${responsablePrenom} ${responsableNom}`,
      phoneNumber: telephone,
      emailVerified: false,
    });

    // âœ… 2. Ajouter le restaurant
    const restaurantDoc = await db.collection("restaurants").add({
      nom: nomRestaurant,
      adresse,
      responsableNom: `${responsablePrenom} ${responsableNom}`,
      emailResponsable: responsableEmail,
      responsableId: userRecord.uid,
      createdAt: Timestamp.now(),
    });

    // âœ… 3. Ajouter le doc utilisateur liÃ©
    await db.collection("utilisateurs").doc(userRecord.uid).set({
      nom: responsableNom,
      prenom: responsablePrenom,
      email: responsableEmail,
      telephone,
      role: "responsable",
      restaurantId: restaurantDoc.id,
      createdAt: Timestamp.now(),
      updatedAt: Timestamp.now(),
    });

    res.status(201).json({ 
      message: "Restaurant et responsable crÃ©Ã©s avec succÃ¨s", 
      restaurantId: restaurantDoc.id,
      responsableUid: userRecord.uid
    });

  } catch (error) {
    console.error("Erreur crÃ©ation restaurant et responsable :", error);
    if (error.code === "auth/email-already-exists") {
      return res.status(400).json({ error: "Cet email est dÃ©jÃ  utilisÃ©" });
    }
    if (error.code === "auth/phone-number-already-exists") {
      return res.status(400).json({ error: "Ce numÃ©ro est dÃ©jÃ  utilisÃ©" });
    }
    res.status(500).json({ error: "Erreur serveur" });
  }
});






// PATCH /auth/profil (responsable connectÃ©)
app.patch("/auth/profil", authMiddleware, async (req, res) => {
  const { nom, prenom, telephone, email, password } = req.body;

  try {
    const uid = req.user.uid;

    const updates = {};
    if (nom) updates.nom = nom;
    if (prenom) updates.prenom = prenom;
    if (telephone) updates.telephone = telephone;
    if (email) updates.email = email;

    // ðŸ”„ 1. Mise Ã  jour Firestore
    if (Object.keys(updates).length > 0) {
      updates.updatedAt = Timestamp.now();
      await db.collection("utilisateurs").doc(uid).update(updates);
    }

    // ðŸ”’ 2. Mise Ã  jour Auth
    const authUpdates = {};
    if (nom && prenom) authUpdates.displayName = `${prenom} ${nom}`;
    if (telephone) authUpdates.phoneNumber = telephone;
    if (email) authUpdates.email = email;
    if (password) authUpdates.password = password;

    if (Object.keys(authUpdates).length > 0) {
      await getAuth().updateUser(uid, authUpdates);
    }

    res.status(200).json({ message: "Profil mis Ã  jour avec succÃ¨s" });

  } catch (error) {
    console.error("Erreur mise Ã  jour profil :", error);
    if (error.code === "auth/email-already-exists") {
      return res.status(400).json({ error: "Cet email est dÃ©jÃ  utilisÃ©" });
    }
    if (error.code === "auth/phone-number-already-exists") {
      return res.status(400).json({ error: "Ce numÃ©ro est dÃ©jÃ  utilisÃ©" });
    }
    res.status(500).json({ error: "Erreur lors de la mise Ã  jour du profil" });
  }
});




module.exports = app;

